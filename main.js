/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MarkwhenSync
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  markwhenPath: "timeline.mw",
  notesFolderPath: "notes",
  enableBidirectionalSync: true,
  enableAutoSync: false,
  autoSyncInterval: "60",
  customProperty: "status",
  propertyConfig: {
    dateProperty: "date",
    endDateProperty: "endDate",
    allowInlineProperties: false
  },
  bidirectionalSyncConfig: {
    syncDates: true,
    syncStatus: true,
    // Defaulting to true based on previous user settings
    syncGroup: true
    // Defaulting to true based on previous user settings
  },
  tagConfig: {
    propertyName: "tags",
    tags: [],
    requireAllTags: false
  },
  groupingConfig: {
    enabled: false,
    propertyName: "group",
    sortBy: "date",
    sortEntriesBy: "date"
  },
  formattingConfig: {
    showStatusTags: true,
    dateFormat: "YYYY-MM-DD",
    groupStartText: "group",
    groupEndText: "end group",
    supportISODateFormat: true
    // Defaulting to true based on previous user settings
  },
  filterConfig: {
    excludeStatus: [],
    enableDateFilter: false,
    dateFilterType: "all",
    excludeFolders: []
  },
  notificationConfig: {
    enabled: true,
    detailLevel: "normal",
    showErrors: true
  },
  debugConfig: {
    enabled: false,
    logLevel: "error",
    dryRun: false
  },
  timelineHeader: ""
  // Default empty header
};
var MarkwhenSyncSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.addBasicSettings(containerEl);
    new import_obsidian.Setting(containerEl).setName("Synchronization").setHeading();
    this.addSyncSettings(containerEl);
    new import_obsidian.Setting(containerEl).setName("Properties").setHeading();
    this.addPropertySettings(containerEl);
    new import_obsidian.Setting(containerEl).setName("Bidirectional sync options").setHeading();
    this.addBidirectionalSyncSettings(containerEl);
    new import_obsidian.Setting(containerEl).setName("Tag configuration").setHeading();
    this.addTagSettings(containerEl);
    new import_obsidian.Setting(containerEl).setName("Grouping").setHeading();
    this.addGroupingSettings(containerEl);
    new import_obsidian.Setting(containerEl).setName("Format").setHeading();
    this.addFormatSettings(containerEl);
    new import_obsidian.Setting(containerEl).setName("Filter").setHeading();
    this.addFilterSettings(containerEl);
    new import_obsidian.Setting(containerEl).setName("Notification").setHeading();
    this.addNotificationSettings(containerEl);
    new import_obsidian.Setting(containerEl).setName("Debug").setHeading();
    this.addDebugSettings(containerEl);
  }
  // Helper method to add settings sections
  addBasicSettings(containerEl) {
    new import_obsidian.Setting(containerEl).setName("Timeline file path").setDesc("Path to your Markwhen timeline file").addText((text) => text.setPlaceholder("timeline.mw").setValue(this.plugin.settings.markwhenPath).onChange(async (value) => {
      this.plugin.settings.markwhenPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Notes folder path").setDesc("Path to your notes folder (leave blank to sync entire vault)").addText((text) => text.setPlaceholder("notes").setValue(this.plugin.settings.notesFolderPath).onChange(async (value) => {
      this.plugin.settings.notesFolderPath = value;
      await this.plugin.saveSettings();
    }));
  }
  addPropertySettings(containerEl) {
    new import_obsidian.Setting(containerEl).setName("Date property").setDesc("Name of the property used for the start date").addText((text) => text.setPlaceholder("date").setValue(this.plugin.settings.propertyConfig.dateProperty).onChange(async (value) => {
      this.plugin.settings.propertyConfig.dateProperty = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("End date property").setDesc("Name of the property used for the end date").addText((text) => text.setPlaceholder("endDate").setValue(this.plugin.settings.propertyConfig.endDateProperty).onChange(async (value) => {
      this.plugin.settings.propertyConfig.endDateProperty = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Allow inline properties").setDesc('Allow properties defined in the note body using the "property:: value" syntax').addToggle((toggle) => toggle.setValue(this.plugin.settings.propertyConfig.allowInlineProperties).onChange(async (value) => {
      this.plugin.settings.propertyConfig.allowInlineProperties = value;
      await this.plugin.saveSettings();
    }));
  }
  addBidirectionalSyncSettings(containerEl) {
    new import_obsidian.Setting(containerEl).setName("Sync dates bidirectionally").setDesc("Synchronize date properties in both directions").addToggle((toggle) => toggle.setValue(this.plugin.settings.bidirectionalSyncConfig.syncDates).onChange(async (value) => {
      this.plugin.settings.bidirectionalSyncConfig.syncDates = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Sync status bidirectionally").setDesc("Synchronize status property in both directions").addToggle((toggle) => toggle.setValue(this.plugin.settings.bidirectionalSyncConfig.syncStatus).onChange(async (value) => {
      this.plugin.settings.bidirectionalSyncConfig.syncStatus = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Sync group bidirectionally").setDesc("Synchronize group property in both directions").addToggle((toggle) => toggle.setValue(this.plugin.settings.bidirectionalSyncConfig.syncGroup).onChange(async (value) => {
      this.plugin.settings.bidirectionalSyncConfig.syncGroup = value;
      await this.plugin.saveSettings();
    }));
  }
  addSyncSettings(containerEl) {
    new import_obsidian.Setting(containerEl).setName("Enable bidirectional sync").setDesc("Sync changes in both directions, otherwise the synchronisations is only from the notes to the timeline").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableBidirectionalSync).onChange(async (value) => {
      this.plugin.settings.enableBidirectionalSync = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Enable auto sync").setDesc("Automatically sync when files change").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAutoSync).onChange(async (value) => {
      this.plugin.settings.enableAutoSync = value;
      await this.plugin.saveSettings();
      this.plugin.setupAutoSync();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto sync interval").setDesc("Interval in seconds for auto sync").addText((text) => text.setPlaceholder("60").setValue(this.plugin.settings.autoSyncInterval).onChange(async (value) => {
      const intervalNum = parseInt(value);
      if (!isNaN(intervalNum) && intervalNum > 0) {
        this.plugin.settings.autoSyncInterval = value;
        await this.plugin.saveSettings();
        this.plugin.setupAutoSync();
      } else {
        new import_obsidian.Notice("Please enter a valid positive number for the interval.");
      }
    }));
  }
  addTagSettings(containerEl) {
    new import_obsidian.Setting(containerEl).setName("Tags property name").setDesc("Name of the frontmatter property that contains tags").addText((text) => text.setPlaceholder("tags").setValue(this.plugin.settings.tagConfig.propertyName).onChange(async (value) => {
      this.plugin.settings.tagConfig.propertyName = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Required tags").setDesc("Tags required for sync (comma-separated)").addText((text) => text.setPlaceholder("tag1, tag2").setValue(this.plugin.settings.tagConfig.tags.join(", ")).onChange(async (value) => {
      this.plugin.settings.tagConfig.tags = value.split(",").map((t) => t.trim()).filter((t) => t !== "");
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Require all tags").setDesc("Require all specified tags (instead of any)").addToggle((toggle) => toggle.setValue(this.plugin.settings.tagConfig.requireAllTags).onChange(async (value) => {
      this.plugin.settings.tagConfig.requireAllTags = value;
      await this.plugin.saveSettings();
    }));
  }
  addGroupingSettings(containerEl) {
    new import_obsidian.Setting(containerEl).setName("Enable grouping").setDesc("Group entries in timeline").addToggle((toggle) => toggle.setValue(this.plugin.settings.groupingConfig.enabled).onChange(async (value) => {
      this.plugin.settings.groupingConfig.enabled = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Grouping property").setDesc("Property name for grouping").addText((text) => text.setPlaceholder("group").setValue(this.plugin.settings.groupingConfig.propertyName).onChange(async (value) => {
      this.plugin.settings.groupingConfig.propertyName = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Group sort method").setDesc("How to sort the groups").addDropdown((dropdown) => dropdown.addOption("date", "By Date").addOption("alpha", "Alphabetically").addOption("number", "By Number").setValue(this.plugin.settings.groupingConfig.sortBy).onChange(async (value) => {
      this.plugin.settings.groupingConfig.sortBy = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Entry sort method").setDesc("How to sort entries within groups").addDropdown((dropdown) => dropdown.addOption("date", "By Date").addOption("alpha", "Alphabetically").setValue(this.plugin.settings.groupingConfig.sortEntriesBy).onChange(async (value) => {
      this.plugin.settings.groupingConfig.sortEntriesBy = value;
      await this.plugin.saveSettings();
    }));
  }
  addFormatSettings(containerEl) {
    new import_obsidian.Setting(containerEl).setName("Show status tags").setDesc("Show status as tags in timeline").addToggle((toggle) => toggle.setValue(this.plugin.settings.formattingConfig.showStatusTags).onChange(async (value) => {
      this.plugin.settings.formattingConfig.showStatusTags = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Date format").setDesc("Format for dates in timeline (using Moment.js syntax)").addText((text) => text.setPlaceholder("YYYY-MM-DD").setValue(this.plugin.settings.formattingConfig.dateFormat).onChange(async (value) => {
      this.plugin.settings.formattingConfig.dateFormat = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Support ISO date format").setDesc('Support ISO date format in timeline (e.g., "2025-09-30T22:00:00.000Z - 2027-07-02T23:00:00.000Z")').addToggle((toggle) => toggle.setValue(this.plugin.settings.formattingConfig.supportISODateFormat).onChange(async (value) => {
      this.plugin.settings.formattingConfig.supportISODateFormat = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Custom property").setDesc("Name of the custom frontmatter property to use for status tags in timeline").addText((text) => text.setPlaceholder("status").setValue(this.plugin.settings.customProperty).onChange(async (value) => {
      this.plugin.settings.customProperty = value;
      await this.plugin.saveSettings();
    }));
  }
  addFilterSettings(containerEl) {
    new import_obsidian.Setting(containerEl).setName("Excluded property value").setDesc("Property values to exclude (comma-separated)").addText((text) => text.setPlaceholder("done, cancelled").setValue(this.plugin.settings.filterConfig.excludeStatus.join(", ")).onChange(async (value) => {
      this.plugin.settings.filterConfig.excludeStatus = value.split(",").map((s) => s.trim()).filter((s) => s !== "");
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Enable date filter").setDesc("Filter entries based on dates").addToggle((toggle) => toggle.setValue(this.plugin.settings.filterConfig.enableDateFilter).onChange(async (value) => {
      this.plugin.settings.filterConfig.enableDateFilter = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Date filter type").setDesc("Which entries to include based on date").addDropdown((dropdown) => dropdown.addOption("all", "All").addOption("future", "Future only").addOption("current", "Current only").setValue(this.plugin.settings.filterConfig.dateFilterType).onChange(async (value) => {
      this.plugin.settings.filterConfig.dateFilterType = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Excluded folders").setDesc("Subfolders to exclude (comma-separated, relative to Notes Folder Path; if blank, relative to vault root)").addText((text) => text.setPlaceholder("archive, temp").setValue(this.plugin.settings.filterConfig.excludeFolders.join(", ")).onChange(async (value) => {
      this.plugin.settings.filterConfig.excludeFolders = value.split(",").map((f) => f.trim()).filter((f) => f !== "");
      await this.plugin.saveSettings();
    }));
  }
  addNotificationSettings(containerEl) {
    new import_obsidian.Setting(containerEl).setName("Enable notifications").setDesc("Show notification popups").addToggle((toggle) => toggle.setValue(this.plugin.settings.notificationConfig.enabled).onChange(async (value) => {
      this.plugin.settings.notificationConfig.enabled = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Detail level").setDesc("How detailed should notifications be").addDropdown((dropdown) => dropdown.addOption("minimal", "Minimal").addOption("normal", "Normal").addOption("detailed", "Detailed").setValue(this.plugin.settings.notificationConfig.detailLevel).onChange(async (value) => {
      this.plugin.settings.notificationConfig.detailLevel = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Show errors").setDesc("Show error notifications").addToggle((toggle) => toggle.setValue(this.plugin.settings.notificationConfig.showErrors).onChange(async (value) => {
      this.plugin.settings.notificationConfig.showErrors = value;
      await this.plugin.saveSettings();
    }));
  }
  addDebugSettings(containerEl) {
    new import_obsidian.Setting(containerEl).setName("Debug mode").setDesc("Enable debug logging in the developer console").addToggle((toggle) => toggle.setValue(this.plugin.settings.debugConfig.enabled).onChange(async (value) => {
      this.plugin.settings.debugConfig.enabled = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Log level").setDesc("Level of debug logging").addDropdown((dropdown) => dropdown.addOption("error", "Errors only").addOption("warn", "Warnings and errors").addOption("info", "General info").addOption("debug", "Detailed debug").setValue(this.plugin.settings.debugConfig.logLevel).onChange(async (value) => {
      this.plugin.settings.debugConfig.logLevel = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Dry run").setDesc("Simulate sync without making changes").addToggle((toggle) => toggle.setValue(this.plugin.settings.debugConfig.dryRun).onChange(async (value) => {
      this.plugin.settings.debugConfig.dryRun = value;
      await this.plugin.saveSettings();
    }));
  }
};
var MarkwhenSync = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    // Store last sync state to compare changes
    this.lastSync = { notes: /* @__PURE__ */ new Map(), timeline: "" };
    // Interval ID for auto-sync
    this.autoSyncIntervalId = null;
  }
  // Determine if a given path should be considered within the notes scope
  isPathInNotesScope(path) {
    var _a;
    const folder = (((_a = this.settings) == null ? void 0 : _a.notesFolderPath) || "").trim();
    if (!folder)
      return true;
    return path.startsWith(folder + "/");
  }
  // Find a note file by event note name, honoring folder scope and avoiding ambiguity
  findNoteFileByName(noteName) {
    var _a;
    const folder = (((_a = this.settings) == null ? void 0 : _a.notesFolderPath) || "").trim();
    if (folder) {
      const notePath = `${folder}/${noteName}.md`;
      const f = this.app.vault.getAbstractFileByPath(notePath);
      return f instanceof import_obsidian.TFile ? f : null;
    }
    const matches = this.app.vault.getMarkdownFiles().filter((f) => f.basename === noteName);
    if (matches.length === 1)
      return matches[0];
    if (matches.length > 1) {
      this.log("warn", `Multiple notes named "${noteName}" found in vault; skipping ambiguous update.`);
    }
    return null;
  }
  // Extract a header block from an existing Markwhen file (lines before first event/group)
  extractHeaderFromTimeline(content) {
    try {
      const lines = content.split(/\r?\n/);
      const groupStartTextLower = this.settings.formattingConfig.groupStartText.toLowerCase();
      const groupEndTextLower = this.settings.formattingConfig.groupEndText.toLowerCase();
      const eventLineRegex = /^(.*?):\s*\[\[(.*?)]](?:\s*(#[\w-]+))?\s*$/;
      const headerLines = [];
      for (let i = 0; i < lines.length; i++) {
        const raw = lines[i];
        const trimmed = raw.trim();
        const lower = trimmed.toLowerCase();
        const isEvent = eventLineRegex.test(trimmed);
        const isGroupStart = lower.startsWith(groupStartTextLower + " ");
        const isGroupEnd = lower === groupEndTextLower;
        if (isEvent || isGroupStart || isGroupEnd)
          break;
        headerLines.push(raw);
      }
      return headerLines.join("\n").trim();
    } catch (e) {
      this.log("warn", "Failed to extract header from timeline; proceeding without preserving header.", e);
      return "";
    }
  }
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("sync", "Sync timeline", async () => {
      await this.syncWithSettings();
    });
    this.addSettingTab(new MarkwhenSyncSettingTab(this.app, this));
    this.setupAutoSync();
    this.debouncedHandleFileChange = (0, import_obsidian.debounce)(
      this.handleFileChange.bind(this),
      // Function to debounce
      1500,
      // Debounce interval in ms
      true
      // Execute on leading edge
    );
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (this.settings.enableAutoSync && file instanceof import_obsidian.TFile) {
          this.debouncedHandleFileChange(file);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (this.settings.enableAutoSync && file instanceof import_obsidian.TFile && file.extension === "md" && this.isPathInNotesScope(file.path)) {
          this.log("debug", `Note created (${file.path}), triggering sync to Markwhen.`);
          this.syncToMarkwhen();
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", (file) => {
        if (this.settings.enableAutoSync) {
          if (file instanceof import_obsidian.TFile && this.isPathInNotesScope(file.path)) {
            this.log("debug", `Note deleted (${file.path}), triggering sync to Markwhen.`);
            this.syncToMarkwhen();
            this.lastSync.notes.delete(file.path);
          } else if (file.path === this.settings.markwhenPath) {
            this.log("info", `Timeline file deleted (${file.path}). Clearing last sync state.`);
            this.lastSync.timeline = "";
          }
        }
      })
    );
    this.log("info", "Markwhen Sync plugin loaded.");
  }
  // Load settings, merging defaults with saved data
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.settings.propertyConfig = Object.assign({}, DEFAULT_SETTINGS.propertyConfig, this.settings.propertyConfig);
    this.settings.bidirectionalSyncConfig = Object.assign({}, DEFAULT_SETTINGS.bidirectionalSyncConfig, this.settings.bidirectionalSyncConfig);
    this.settings.tagConfig = Object.assign({}, DEFAULT_SETTINGS.tagConfig, this.settings.tagConfig);
    this.settings.groupingConfig = Object.assign({}, DEFAULT_SETTINGS.groupingConfig, this.settings.groupingConfig);
    this.settings.formattingConfig = Object.assign({}, DEFAULT_SETTINGS.formattingConfig, this.settings.formattingConfig);
    this.settings.filterConfig = Object.assign({}, DEFAULT_SETTINGS.filterConfig, this.settings.filterConfig);
    this.settings.notificationConfig = Object.assign({}, DEFAULT_SETTINGS.notificationConfig, this.settings.notificationConfig);
    this.settings.debugConfig = Object.assign({}, DEFAULT_SETTINGS.debugConfig, this.settings.debugConfig);
  }
  // Save settings to Obsidian's storage
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // Set up or clear the auto-sync interval based on settings
  setupAutoSync() {
    if (this.autoSyncIntervalId !== null) {
      window.clearInterval(this.autoSyncIntervalId);
      this.autoSyncIntervalId = null;
    }
    if (this.settings.enableAutoSync) {
      const intervalSeconds = parseInt(this.settings.autoSyncInterval);
      if (!isNaN(intervalSeconds) && intervalSeconds > 0) {
        const intervalMilliseconds = intervalSeconds * 1e3;
        this.autoSyncIntervalId = window.setInterval(() => this.syncWithSettings(), intervalMilliseconds);
        this.registerInterval(this.autoSyncIntervalId);
        this.log("info", `Auto-sync interval set to ${intervalSeconds} seconds.`);
      } else {
        this.log("warn", "Invalid auto-sync interval. Auto-sync disabled.");
      }
    } else {
      this.log("info", "Auto-sync disabled.");
    }
  }
  // Handle file changes detected by the vault listener
  async handleFileChange(file) {
    if (file.path === this.settings.markwhenPath) {
      this.log("debug", "Timeline file modified, syncing from Markwhen.");
      await this.syncFromMarkwhen();
    } else if (this.isPathInNotesScope(file.path) && file.extension === "md") {
      this.log("debug", `Note file modified (${file.path}), syncing to Markwhen.`);
      await this.syncToMarkwhen();
    }
  }
  // Perform sync based on current settings (manual trigger or interval)
  async syncWithSettings() {
    this.log("info", "Starting sync cycle.");
    if (this.settings.debugConfig.dryRun) {
      new import_obsidian.Notice("Dry run: Simulating sync.");
      this.log("info", "Dry run enabled, no actual changes will be made.");
      return;
    }
    try {
      await this.syncToMarkwhen();
      if (this.settings.enableBidirectionalSync) {
        await this.syncFromMarkwhen();
      }
      if (this.settings.notificationConfig.enabled && this.settings.notificationConfig.detailLevel !== "minimal") {
        new import_obsidian.Notice("Sync complete.");
      }
      this.log("info", "Sync cycle finished.");
    } catch (error) {
      let errorMessage = "Unknown error during sync cycle";
      if (error instanceof Error) {
        errorMessage = error.message;
      } else if (typeof error === "string") {
        errorMessage = error;
      }
      this.log("error", "Error during sync cycle:", error);
      if (this.settings.notificationConfig.showErrors) {
        new import_obsidian.Notice(`Sync error: ${errorMessage}`);
      }
    }
  }
  // Collect valid entries from the notes folder
  async collectEntries() {
    const entries = [];
    const notesFolderPathRaw = this.settings.notesFolderPath || "";
    const notesFolderPath = notesFolderPathRaw.trim();
    const includeAll = notesFolderPath === "";
    let baseFolder = null;
    if (!includeAll) {
      const af = this.app.vault.getAbstractFileByPath(notesFolderPath);
      if (!(af instanceof import_obsidian.TFolder)) {
        const errorMsg = `Notes folder path "${notesFolderPath}" not found or is not a folder.`;
        this.log("error", errorMsg);
        if (this.settings.notificationConfig.showErrors)
          new import_obsidian.Notice(errorMsg);
        return [];
      }
      baseFolder = af;
    }
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      if (!includeAll) {
        if (!file.path.startsWith(baseFolder.path + "/"))
          continue;
      }
      const relativePath = includeAll ? file.path : file.path.substring(baseFolder.path.length + 1);
      if (this.settings.filterConfig.excludeFolders.some((folder) => relativePath.startsWith(folder + "/"))) {
        this.log("debug", `Skipping excluded file: ${file.path}`);
        continue;
      }
      const cache = this.app.metadataCache.getFileCache(file);
      const frontmatter = (cache == null ? void 0 : cache.frontmatter) || {};
      let metadata = { ...frontmatter };
      if (this.settings.propertyConfig.allowInlineProperties) {
        try {
          const content = await this.app.vault.cachedRead(file);
          const inlineProps = this.extractInlineProperties(content);
          for (const key in inlineProps) {
            if (!metadata.hasOwnProperty(key)) {
              metadata[key] = inlineProps[key];
            }
          }
        } catch (readError) {
          this.log("error", `Error reading file for inline properties: ${file.path}`, readError);
          continue;
        }
      }
      if (this.isValidEntry(metadata, file.basename)) {
        entries.push({
          file,
          metadata,
          title: file.basename
        });
      }
    }
    this.log("debug", `Collected ${entries.length} valid entries.`);
    return entries;
  }
  // Helper function for manual inline property extraction (fallback)
  extractInlineProperties(content) {
    const props = {};
    const propertyRegex = /^\s*(?:\[|\()?\s*([a-zA-Z0-9_\-]+)\s*::\s*([^\]\)\n]+?)\s*(?:\]|\))?\s*$/gm;
    let match;
    while ((match = propertyRegex.exec(content)) !== null) {
      const key = match[1].trim();
      let value = match[2].trim();
      if (!isNaN(Number(value)) && value.trim() !== "") {
        value = Number(value);
      } else if (value.toLowerCase() === "true") {
        value = true;
      } else if (value.toLowerCase() === "false") {
        value = false;
      }
      if (!props.hasOwnProperty(key)) {
        props[key] = value;
      }
    }
    return props;
  }
  // Format a date string according to settings, handling partial dates
  formatDate(dateString, isEndDate = false) {
    if (!dateString || typeof dateString !== "string")
      return "";
    const targetFormat = this.settings.formattingConfig.dateFormat;
    let dateMoment = window.moment(dateString, targetFormat, true);
    if (!dateMoment.isValid()) {
      dateMoment = window.moment(dateString);
    }
    if (/^\d{4}$/.test(dateString)) {
      const yearMoment = window.moment(dateString, "YYYY");
      return isEndDate ? yearMoment.endOf("year").format(targetFormat) : yearMoment.startOf("year").format(targetFormat);
    } else if (/^\d{4}-\d{2}$/.test(dateString)) {
      const monthMoment = window.moment(dateString, "YYYY-MM");
      return isEndDate ? monthMoment.endOf("month").format(targetFormat) : monthMoment.startOf("month").format(targetFormat);
    }
    if (!dateMoment.isValid()) {
      this.log("warn", `Invalid date format encountered: "${dateString}". Could not parse.`);
      return dateString;
    }
    return dateMoment.format(targetFormat);
  }
  // Convert ISO date string to the format specified in settings
  formatISODateToNormal(isoDate) {
    if (!isoDate || typeof isoDate !== "string")
      return null;
    try {
      const dateMoment = window.moment.utc(isoDate);
      if (dateMoment.isValid()) {
        return dateMoment.format(this.settings.formattingConfig.dateFormat);
      } else {
        this.log("warn", `Could not parse ISO date using moment.utc: "${isoDate}"`);
        return null;
      }
    } catch (error) {
      this.log("error", `Error parsing ISO date "${isoDate}":`, error);
      return null;
    }
  }
  // Sync changes from collected entries to the Markwhen timeline file
  async syncToMarkwhen() {
    this.log("info", "Starting sync to Markwhen timeline.");
    try {
      const timelinePath = this.settings.markwhenPath;
      let markwhenFile = this.app.vault.getAbstractFileByPath(timelinePath);
      if (!markwhenFile) {
        this.log("info", `Timeline file "${timelinePath}" not found, attempting to create it.`);
        const parentDir = timelinePath.substring(0, timelinePath.lastIndexOf("/"));
        if (parentDir && !this.app.vault.getAbstractFileByPath(parentDir)) {
          try {
            await this.app.vault.createFolder(parentDir);
            this.log("info", `Created directory "${parentDir}".`);
          } catch (dirError) {
            this.log("error", `Failed to create directory "${parentDir}":`, dirError);
            throw new Error(`Failed to create directory for timeline: ${dirError.message}`);
          }
        }
        try {
          const entries2 = await this.collectEntries();
          const newContentOnCreate = await this.generateTimelineContent(entries2, void 0);
          markwhenFile = await this.app.vault.create(timelinePath, newContentOnCreate.trim());
          this.lastSync.timeline = newContentOnCreate.trim();
          if (this.settings.notificationConfig.enabled) {
            new import_obsidian.Notice(`Created timeline: ${timelinePath}`);
          }
          this.log("info", `Successfully created timeline file "${timelinePath}".`);
          return;
        } catch (createError) {
          this.log("error", `Failed to create timeline file "${timelinePath}":`, createError);
          throw new Error(`Failed to create timeline file: ${createError.message}`);
        }
      }
      if (!(markwhenFile instanceof import_obsidian.TFile)) {
        throw new Error(`Timeline path points to a directory, not a file: ${timelinePath}`);
      }
      const currentContent = await this.app.vault.read(markwhenFile);
      if (this.settings.enableBidirectionalSync && this.lastSync.timeline !== "" && this.lastSync.timeline !== currentContent) {
        this.log("warn", "Timeline file has changed externally since last sync. Skipping sync *to* timeline to avoid overwriting. Please sync manually if needed.");
        if (this.settings.notificationConfig.enabled) {
          new import_obsidian.Notice("Timeline changed externally. Sync paused.");
        }
        return;
      }
      const preservedHeader = this.extractHeaderFromTimeline(currentContent);
      const entries = await this.collectEntries();
      const newContent = await this.generateTimelineContent(entries, preservedHeader);
      if (newContent.trim() !== currentContent.trim()) {
        this.log("info", `Timeline content differs, updating file "${timelinePath}".`);
        await this.app.vault.modify(markwhenFile, newContent.trim());
        this.lastSync.timeline = newContent.trim();
        if (this.settings.notificationConfig.enabled && this.settings.notificationConfig.detailLevel !== "minimal") {
          new import_obsidian.Notice("Timeline synchronized");
        }
      } else {
        this.log("debug", "Timeline content is already up-to-date.");
      }
    } catch (error) {
      this.log("error", "Error during sync to timeline:", error);
      if (this.settings.notificationConfig.showErrors) {
        new import_obsidian.Notice(`Error syncing to timeline: ${error.message || "Unknown error"}`);
      }
    }
  }
  // Sync changes from the Markwhen timeline file back to Obsidian notes
  async syncFromMarkwhen() {
    if (!this.settings.enableBidirectionalSync) {
      this.log("info", "Bidirectional sync disabled, skipping sync from Markwhen.");
      return;
    }
    this.log("info", "Starting sync from Markwhen timeline.");
    try {
      const markwhenFile = this.app.vault.getAbstractFileByPath(this.settings.markwhenPath);
      if (!markwhenFile) {
        this.log("warn", `Timeline file "${this.settings.markwhenPath}" not found, cannot sync from it.`);
        return;
      }
      if (!(markwhenFile instanceof import_obsidian.TFile)) {
        this.log("error", `Timeline path "${this.settings.markwhenPath}" points to a directory.`);
        if (this.settings.notificationConfig.showErrors) {
          new import_obsidian.Notice(`Timeline path is a directory: ${this.settings.markwhenPath}`);
        }
        return;
      }
      const content = await this.app.vault.read(markwhenFile);
      if (content === this.lastSync.timeline) {
        this.log("debug", "Timeline content unchanged since last sync, skipping sync from Markwhen.");
        return;
      }
      const timelineEvents = this.parseMarkwhenContent(content);
      this.log("debug", `Parsed ${timelineEvents.length} events from timeline.`);
      let updatedNotesCount = 0;
      for (const event of timelineEvents) {
        if (event.startDate && event.endDate) {
          const updated = await this.updateNoteFromEvent(event);
          if (updated)
            updatedNotesCount++;
        } else {
          this.log("warn", `Skipping update for event "${event.noteName}" due to invalid parsed dates (Start: ${event.startDate}, End: ${event.endDate}).`);
        }
      }
      if (updatedNotesCount > 0 && this.settings.notificationConfig.enabled && this.settings.notificationConfig.detailLevel === "detailed") {
        new import_obsidian.Notice(`Updated ${updatedNotesCount} notes from timeline.`);
      }
      this.lastSync.timeline = content;
      this.log("info", "Finished sync from Markwhen timeline.");
    } catch (error) {
      this.log("error", "Error during sync from timeline:", error);
      if (this.settings.notificationConfig.showErrors) {
        new import_obsidian.Notice(`Error syncing from timeline: ${error.message || "Unknown error"}`);
      }
    }
  }
  // Parse the content of the Markwhen file into structured events
  parseMarkwhenContent(content) {
    const events = [];
    const lines = content.split(/\r?\n/);
    let currentGroup = null;
    const groupStartTextLower = this.settings.formattingConfig.groupStartText.toLowerCase();
    const groupEndTextLower = this.settings.formattingConfig.groupEndText.toLowerCase();
    const eventLineRegex = /^(.*?):\s*\[\[(.*?)]](?:\s*(#[\w-]+))?\s*$/;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const trimmedLine = line.trim();
      if (trimmedLine === "")
        continue;
      const trimmedLineLower = trimmedLine.toLowerCase();
      if (trimmedLineLower.startsWith(groupStartTextLower + " ")) {
        currentGroup = trimmedLine.substring(this.settings.formattingConfig.groupStartText.length + 1).trim();
        this.log("debug", `Line ${i + 1}: Started group "${currentGroup}"`);
        continue;
      } else if (trimmedLineLower === groupEndTextLower) {
        this.log("debug", `Line ${i + 1}: Ended group "${currentGroup}"`);
        currentGroup = null;
        continue;
      }
      const match = trimmedLine.match(eventLineRegex);
      if (match) {
        const dateRangePart = match[1].trim();
        const noteName = match[2].trim();
        const statusTag = match[3] ? match[3].substring(1) : null;
        let startDate = null;
        let endDate = null;
        if (this.settings.formattingConfig.supportISODateFormat && dateRangePart.includes("T") && dateRangePart.includes("Z")) {
          const isoParts = dateRangePart.split(/\s*-\s*/);
          if (isoParts.length >= 1 && isoParts[0]) {
            startDate = this.formatISODateToNormal(isoParts[0]);
            endDate = isoParts.length === 2 && isoParts[1] ? this.formatISODateToNormal(isoParts[1]) : startDate;
            if (startDate === null || endDate === null) {
              this.log("warn", `Line ${i + 1}: Failed to parse ISO date range: "${dateRangePart}" for note "[[${noteName}]]". Skipping event.`);
              continue;
            }
          } else {
            this.log("warn", `Line ${i + 1}: Could not split ISO date range correctly: "${dateRangePart}" for note "[[${noteName}]]". Skipping event.`);
            continue;
          }
        } else {
          const dateParts = dateRangePart.split("/");
          if (dateParts.length > 0 && dateParts[0].trim()) {
            startDate = this.formatDate(dateParts[0].trim());
            endDate = dateParts.length === 2 && dateParts[1].trim() ? this.formatDate(dateParts[1].trim(), true) : startDate;
            if (!window.moment(startDate, this.settings.formattingConfig.dateFormat, true).isValid() || !window.moment(endDate, this.settings.formattingConfig.dateFormat, true).isValid()) {
              this.log("warn", `Line ${i + 1}: Failed to parse standard date range or result is invalid according to format '${this.settings.formattingConfig.dateFormat}': "${dateRangePart}" -> "${startDate}" / "${endDate}" for note "[[${noteName}]]". Skipping event.`);
              continue;
            }
          } else {
            this.log("warn", `Line ${i + 1}: Invalid standard date part: "${dateRangePart}" for note "[[${noteName}]]". Skipping event.`);
            continue;
          }
        }
        if (noteName && startDate && endDate) {
          events.push({
            startDate,
            endDate,
            noteName,
            group: currentGroup,
            status: statusTag
          });
        } else {
          this.log("warn", `Line ${i + 1}: Could not create valid event from line: "${trimmedLine}" (Note: ${noteName}, Start: ${startDate}, End: ${endDate})`);
        }
      } else {
        this.log("debug", `Line ${i + 1}: Does not match event format: "${trimmedLine}"`);
      }
    }
    return events;
  }
  // Update an Obsidian note based on a parsed timeline event
  async updateNoteFromEvent(event) {
    if (!this.settings.enableBidirectionalSync)
      return false;
    const noteFile = this.findNoteFileByName(event.noteName);
    if (!(noteFile instanceof import_obsidian.TFile)) {
      return false;
    }
    const df = this.settings.formattingConfig.dateFormat;
    if (!event.startDate || !event.endDate || !window.moment(event.startDate, df, true).isValid() || !window.moment(event.endDate, df, true).isValid()) {
      this.log("warn", `Skipping update for "${event.noteName}" because event dates are invalid or missing after parsing. Start: ${event.startDate}, End: ${event.endDate}`);
      return false;
    }
    const dateProperty = this.settings.propertyConfig.dateProperty;
    const endDateProperty = this.settings.propertyConfig.endDateProperty;
    const groupProperty = this.settings.groupingConfig.propertyName;
    const statusProperty = this.settings.customProperty;
    let updateMade = false;
    try {
      await this.app.fileManager.processFrontMatter(noteFile, (fm) => {
        if (this.settings.bidirectionalSyncConfig.syncDates) {
          if (fm[dateProperty] !== event.startDate) {
            fm[dateProperty] = event.startDate;
            updateMade = true;
            this.log("debug", `Updating "${dateProperty}" for "${event.noteName}" to "${event.startDate}".`);
          }
          if (fm[endDateProperty] !== event.endDate) {
            fm[endDateProperty] = event.endDate;
            updateMade = true;
            this.log("debug", `Updating "${endDateProperty}" for "${event.noteName}" to "${event.endDate}".`);
          }
        }
        if (this.settings.bidirectionalSyncConfig.syncGroup) {
          if (event.group && fm[groupProperty] !== event.group) {
            fm[groupProperty] = event.group;
            updateMade = true;
            this.log("debug", `Updating "${groupProperty}" for "${event.noteName}" to "${event.group}".`);
          } else if (!event.group && fm.hasOwnProperty(groupProperty)) {
            delete fm[groupProperty];
            updateMade = true;
            this.log("debug", `Removing "${groupProperty}" for "${event.noteName}".`);
          }
        }
        if (this.settings.bidirectionalSyncConfig.syncStatus) {
          if (event.status && fm[statusProperty] !== event.status) {
            fm[statusProperty] = event.status;
            updateMade = true;
            this.log("debug", `Updating "${statusProperty}" for "${event.noteName}" to "${event.status}".`);
          } else if (!event.status && fm.hasOwnProperty(statusProperty)) {
            delete fm[statusProperty];
            updateMade = true;
            this.log("debug", `Removing "${statusProperty}" for "${event.noteName}".`);
          }
        }
      });
      if (this.settings.propertyConfig.allowInlineProperties && updateMade) {
        this.log("warn", "Bidirectional sync for inline properties is not fully supported and may be unreliable.");
      }
      if (updateMade) {
        this.log("debug", `Successfully processed updates for note "${event.noteName}".`);
      }
      return updateMade;
    } catch (error) {
      this.log("error", `Error updating note for event "${event.noteName}" using processFrontMatter:`, error);
      if (this.settings.notificationConfig.showErrors) {
        new import_obsidian.Notice(`Error updating note ${event.noteName}: ${error.message || "Unknown error"}`);
      }
      return false;
    }
  }
  // Generate the content for the Markwhen timeline file from entries
  async generateTimelineContent(entries, headerFromFile) {
    let content = "";
    const headerSetting = (this.settings.timelineHeader || "").trim();
    const header = headerSetting !== "" ? headerSetting : headerFromFile ? headerFromFile.trim() : "";
    if (header)
      content += header + "\n\n";
    if (this.settings.groupingConfig.enabled) {
      const grouped = this.groupEntries(entries);
      const sortedGroupKeys = [...grouped.keys()].sort((a, b) => {
        const sortBy = this.settings.groupingConfig.sortBy;
        if (sortBy === "alpha") {
          return String(a).localeCompare(String(b));
        } else if (sortBy === "number") {
          const numA = parseFloat(String(a));
          const numB = parseFloat(String(b));
          return !isNaN(numA) && !isNaN(numB) ? numA - numB : String(a).localeCompare(String(b));
        } else if (sortBy === "date") {
          const earliestDate = (groupEntries) => groupEntries.reduce((earliest, entry) => {
            const entryDate = window.moment(entry.metadata[this.settings.propertyConfig.dateProperty], this.settings.formattingConfig.dateFormat);
            return !earliest || entryDate.isValid() && entryDate.isBefore(earliest) ? entryDate : earliest;
          }, null);
          const dateA = earliestDate(grouped.get(a) || []);
          const dateB = earliestDate(grouped.get(b) || []);
          if (dateA && dateB)
            return dateA.diff(dateB);
          if (dateA)
            return -1;
          if (dateB)
            return 1;
          return String(a).localeCompare(String(b));
        }
        return 0;
      });
      for (const group of sortedGroupKeys) {
        const groupEntries = grouped.get(group) || [];
        content += `
${this.settings.formattingConfig.groupStartText} ${group}
`;
        content += this.formatEntries(groupEntries);
        content += `${this.settings.formattingConfig.groupEndText}
`;
      }
    } else {
      content += this.formatEntries(entries);
    }
    return content.trim();
  }
  // Group entries based on the configured property
  groupEntries(entries) {
    var _a;
    const grouped = /* @__PURE__ */ new Map();
    const groupProperty = this.settings.groupingConfig.propertyName;
    for (const entry of entries) {
      const groupValue = entry.metadata[groupProperty] || "Ungrouped";
      const groupKey = String(groupValue);
      if (!grouped.has(groupKey)) {
        grouped.set(groupKey, []);
      }
      (_a = grouped.get(groupKey)) == null ? void 0 : _a.push(entry);
    }
    return grouped;
  }
  // Format a list of entries into Markwhen syntax lines
  formatEntries(entries) {
    const dateProperty = this.settings.propertyConfig.dateProperty;
    const endDateProperty = this.settings.propertyConfig.endDateProperty;
    const statusProperty = this.settings.customProperty;
    const dateFormat = this.settings.formattingConfig.dateFormat;
    const sortedEntries = [...entries].sort((a, b) => {
      const sortBy = this.settings.groupingConfig.enabled ? this.settings.groupingConfig.sortEntriesBy : "date";
      if (sortBy === "date") {
        const dateA = window.moment(a.metadata[dateProperty], dateFormat);
        const dateB = window.moment(b.metadata[dateProperty], dateFormat);
        if (dateA.isValid() && !dateB.isValid())
          return -1;
        if (!dateA.isValid() && dateB.isValid())
          return 1;
        if (!dateA.isValid() && !dateB.isValid())
          return a.title.localeCompare(b.title);
        return dateA.diff(dateB);
      } else if (sortBy === "alpha") {
        return a.title.localeCompare(b.title);
      }
      return 0;
    });
    let content = "";
    for (const entry of sortedEntries) {
      const startDate = this.formatDate(entry.metadata[dateProperty]);
      const endDate = this.formatDate(entry.metadata[endDateProperty], true);
      let dateRangeString = startDate;
      if (endDate && endDate !== startDate && window.moment(startDate, dateFormat, true).isValid()) {
        dateRangeString += ` / ${endDate}`;
      }
      const statusValue = entry.metadata[statusProperty];
      const statusTag = this.settings.formattingConfig.showStatusTags && statusValue ? ` #${String(statusValue).replace(/\s+/g, "-")}` : "";
      content += `${dateRangeString}: [[${entry.title}]]${statusTag}
`;
    }
    return content;
  }
  // Check if an entry's metadata meets the criteria for syncing
  isValidEntry(metadata, noteTitle = "Untitled") {
    if (!metadata)
      return false;
    const dateProperty = this.settings.propertyConfig.dateProperty;
    const endDateProperty = this.settings.propertyConfig.endDateProperty;
    const statusProperty = this.settings.customProperty;
    const tagsProperty = this.settings.tagConfig.propertyName;
    const dateFormat = this.settings.formattingConfig.dateFormat;
    const startDateValue = metadata[dateProperty];
    const endDateValue = metadata[endDateProperty];
    if (!startDateValue || typeof startDateValue !== "string" || startDateValue.trim() === "" || !endDateValue || typeof endDateValue !== "string" || endDateValue.trim() === "") {
      this.log("debug", `Invalid entry "${noteTitle}" - Missing or empty date properties.`);
      return false;
    }
    if (!window.moment(startDateValue, dateFormat, true).isValid() || !window.moment(endDateValue, dateFormat, true).isValid()) {
      this.log("debug", `Invalid entry "${noteTitle}" - Date format doesn't match settings ('${dateFormat}'). Start: ${startDateValue}, End: ${endDateValue}`);
      return false;
    }
    const statusValue = metadata[statusProperty];
    if (statusValue && this.settings.filterConfig.excludeStatus.length > 0) {
      const lowerCaseStatus = String(statusValue).toLowerCase();
      if (this.settings.filterConfig.excludeStatus.map((s) => s.toLowerCase()).includes(lowerCaseStatus)) {
        this.log("debug", `Invalid entry "${noteTitle}" - Excluded status: "${statusValue}"`);
        return false;
      }
    }
    const requiredTags = this.settings.tagConfig.tags;
    if (requiredTags && requiredTags.length > 0 && requiredTags[0] !== "") {
      let entryTagsRaw = metadata[tagsProperty];
      let entryTags = [];
      if (!entryTagsRaw) {
        entryTags = [];
      } else if (typeof entryTagsRaw === "string") {
        entryTags = entryTagsRaw.split(/[, ]+/).map((t) => t.trim().toLowerCase()).filter((t) => t !== "");
      } else if (Array.isArray(entryTagsRaw)) {
        entryTags = entryTagsRaw.map((t) => String(t).toLowerCase().trim()).filter((t) => t !== "");
      } else {
        entryTags = [String(entryTagsRaw).toLowerCase().trim()].filter((t) => t !== "");
      }
      const lowerCaseRequiredTags = requiredTags.map((t) => t.toLowerCase());
      if (this.settings.tagConfig.requireAllTags) {
        if (!lowerCaseRequiredTags.every((reqTag) => entryTags.includes(reqTag))) {
          this.log("debug", `Invalid entry "${noteTitle}" - Missing required tags (require all). Needed: ${lowerCaseRequiredTags.join(", ")}, Found: ${entryTags.join(", ")}`);
          return false;
        }
      } else {
        if (!lowerCaseRequiredTags.some((reqTag) => entryTags.includes(reqTag))) {
          this.log("debug", `Invalid entry "${noteTitle}" - Missing required tags (require any). Needed one of: ${lowerCaseRequiredTags.join(", ")}, Found: ${entryTags.join(", ")}`);
          return false;
        }
      }
    }
    if (this.settings.filterConfig.enableDateFilter) {
      const startDate = window.moment(startDateValue, dateFormat);
      const endDate = window.moment(endDateValue, dateFormat);
      const now = window.moment();
      if (!startDate.isValid()) {
        this.log("debug", `Invalid entry "${noteTitle}" - Date filtering enabled but start date is invalid.`);
        return false;
      }
      const filterType = this.settings.filterConfig.dateFilterType;
      if (filterType === "future") {
        if (startDate.isBefore(now.startOf("day"))) {
          this.log("debug", `Invalid entry "${noteTitle}" - Filtered out past event (future only).`);
          return false;
        }
      } else if (filterType === "current") {
        const endCompareDate = endDate.isValid() ? endDate : startDate;
        if (!now.isBetween(startDate, endCompareDate, "day", "[]")) {
          this.log("debug", `Invalid entry "${noteTitle}" - Filtered out non-current event (current only).`);
          return false;
        }
      }
    }
    return true;
  }
  // Cleanup on plugin unload
  onunload() {
    this.log("info", "Markwhen Sync plugin unloaded.");
    if (this.autoSyncIntervalId !== null) {
      window.clearInterval(this.autoSyncIntervalId);
      this.log("debug", "Cleared auto-sync interval manually (onunload).");
    }
    if (this.debouncedHandleFileChange && typeof this.debouncedHandleFileChange.cancel === "function") {
      this.debouncedHandleFileChange.cancel();
      this.log("debug", "Cancelled pending debounced operations.");
    }
  }
  // Helper for logging based on debug settings
  log(level, message, ...args) {
    var _a, _b;
    if (!((_b = (_a = this.settings) == null ? void 0 : _a.debugConfig) == null ? void 0 : _b.enabled))
      return;
    const levelMap = { error: 0, warn: 1, info: 2, debug: 3 };
    const currentLevel = levelMap[this.settings.debugConfig.logLevel];
    const messageLevel = levelMap[level];
    if (messageLevel <= currentLevel) {
      const prefix = `[Markwhen Sync|${level.toUpperCase()}]`;
      if (level === "error") {
        console.error(prefix, message, ...args);
      } else if (level === "warn") {
        console.warn(prefix, message, ...args);
      } else if (level === "info") {
        console.info(prefix, message, ...args);
      } else {
        console.log(prefix, message, ...args);
      }
    }
  }
};
